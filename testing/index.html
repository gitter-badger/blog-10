<!DOCTYPE html>
<html>

<head>
    <title>Talking Tests</title>
    <link rel="stylesheet" type="text/css" href="../Skeleton/css/normalize.css">
    <link rel="stylesheet" type="text/css" href="../Skeleton/css/skeleton.css">
    <link rel="stylesheet" type="text/css" href="../lukejpreston.css">
</head>

<body>
    <br />
    <a class="row offset-by-one ten columns button button-primary" href="..">Home</a>
    <div class="row">
        <h1 class="row offset-by-one columns">The Tests Are Made For Talking</h1>
    </div>
    <div class="row offset-by-one ten columns">
        <p>Testing is not only <b>GOOD PRACTICE</b> but I am 100% convinced it produces <b>GOOD CODE</b>.</p>
        <p>One thing which most people for get is that <b>TESTS TALK</b>. This blog is a list that will help you to <b>MAKE TESTS AMAZING</b>. Also it help with things to watch out for and what you need to do when tests tell you something is wrong.</p>
        <h4>Documentation</h4>
        <h5>Luke's Inner Monologue</h5>
        <p>Something</p>
        <h5>Story Time</h5>
        <p>Something</p>
        <h5>Guidelines</h5>
        <table class="u-full-width">
            <thead>
                <th>Good Naming</th>
                <th>Reason</th>
            </thead>
            <tbody>
                <tr>
                    <td>Only describe one thing</td>
                    <td>If they describe more than one thing then your code does more than one thing. Which means your code is too complex.</td>
                </tr>
                <tr>
                    <td>Do not describe implementation</td>
                    <td>Two reasons wrong when describing implementation. Firstly, the tests are likely to change. Secondly, your code most likely to have very complex logic in it if you are doing this.</td>
                </tr>
                <tr>
                    <td>Are short and to the point</td>
                    <td>Long winded names indicate to me that you don't know what the problem is you are trying to solve, because of the end of the day if you do TDD, don't think "I am writing tests first", instead thing "I am writing the problem first". Your solution is probably wrong and will most certainly confuse anyone else going to the code.</td>
                </tr>
            </tbody>
        </table>
        <!--



































         -->
        <br />
        <br />
        <br />
        <br />
        <br />
        <br />
        <br />
        <br />
        <br />
        <br />
        <br />
        <br />
        <br />
        <br />
        <br />
        <br />
        <br />
        <br />
        <br />
        <br />
        <br />
        <br />
        <br />
        <br />
        <br />
        <br />
        <br />
        <h4>Documentation</h4>
        <h5>Blurb</h5>
        <p>Tests are the <b>documentation of the code</b>. Imagine having documentation which changes when your code does. Documentation which is green and red hinting whether it is correct or not. That is what tests gives you when you do them correctly</p>
        <h5>Narrative</h5>
        <p>Some people complain that tests don't make sense. This is because they have probably adopted a naming convention or something similar which is awful. What I want you to do is imagine you are describing a football (soccer ball?). What would you say and would it be something like this?</p>
        <p><u>A Football</u>
            <br/> Filled with air
            <br/> In the shape of a sphere
            <br/> Is covered in leather</p>
        <p>I can't really think of a better way of writing the description of a football. And now I have 3 tests and 1 test suite. This way if I change the implementation then I don't need to change the tests. I only change the tests if they become invalid. For instance I might get a polyester cover on the ball. At which point that test would change it's name to "Is covered in a material".</p>
        <h5>Guidelines</h5>
        <table class="u-full-width">
            <thead>
                <th>Good Naming</th>
                <th>Reason</th>
            </thead>
            <tbody>
                <tr>
                    <td>Only describe one thing</td>
                    <td>If they describe more than one thing then your code does more than one thing. Which means your code is too complex.</td>
                </tr>
                <tr>
                    <td>Do not describe implementation</td>
                    <td>Two reasons wrong when describing implementation. Firstly, the tests are likely to change. Secondly, your code most likely to have very complex logic in it if you are doing this.</td>
                </tr>
                <tr>
                    <td>Are short and to the point</td>
                    <td>Long winded names indicate to me that you don't know what the problem is you are trying to solve, because of the end of the day if you do TDD, don't think "I am writing tests first", instead thing "I am writing the problem first". Your solution is probably wrong and will most certainly confuse anyone else going to the code.</td>
                </tr>
            </tbody>
        </table>
        <h4>Mocking</h4>
        <h5>Blurb</h5>
        <p>When and how to mock has been the source of many heated debates for me. <b>Mocking highlights coupling</b>. This is true when you over are mocking or mocking the wrong thing or mocking at the wrong level of testing. <b>Mocking makes good code</b>. Might be contradictory but keeping your code independent and consistent from outside things is always a good thing.</p>
        <h5>Narrative</h5>
        <p>Boop</p>
        <h5>Guidelines</h5>
        <table>
            <thead>
                <th>Good Mocking</th>
                <th>Reason</th>
            </thead>
        </table>
        <!--



































         -->
        <br />
        <br />
        <br />
        <br />
        <br />
        <br />
        <br />
        <br />
        <br />
        <br />
        <br />
        <br />
        <br />
        <br />
        <br />
        <br />
        <br />
        <br />
        <br />
        <br />
        <br />
        <br />
        <br />
        <br />
        <br />
        <br />
        <br />
        <h5>
            Have you ever had an argument to anyone about mocks and mocking (spies and spying)?
            Probably because you are either doing it wrong or you more likely you have created coupling.
            Mocks (and spies) tell you that you have coupling in your code.
            You should either argue that this is fine and you can continue.
            Or that you should change how you join your code and reduce the coupling.
            More often than not you have over coupling.
        </h5>
        <h5>
            It is all too often that assertions are hard to write.
            WRONG! Side effects are hard to test.
            If you are writing code with side effects and you haven't noticed
            that either your tests have rubbish names, that tests are hard to write or that mocks are hard to manage!
            Then you probably have rubbish assertions.
            I like trying to keep my tests to have ONE assertion.
            Why? Because everything should do one thing. Even your tests.
        </h5>
        <h5>
            The second last thing which makes tests great is how granular you write them.
            I have written server side solutions and client side solutions.
            The later being notorious to test.
            You can solve this by writing the write <i>kind</i> of test.
            <b>Unit</b> tests are famous for being <i>too</i> granular.
            You can identify these because they have too much mocking,
            they are testing private or protected methods,
            the sheer volume of them and they are overly complex.
            But unit tests are useful for edge case.
            They are quick and small. I think most developers find them easiest to write TBH.
            <b>Integration (or service)</b> tests are good for testing certain components all hooked togeher.
            Unit tests should mock things like Data Sources.
            But you need to test that the data hooks up together.
            You could check with a huge or manual test that takes a long time that the data is coming through correctly.
            HOWEVER you could check with an intermediate test.
            These should not test edge cases, that should be for unit tests.
            But they are normally as quick as the integration (e.g. how long it takes for data to come back).
            Which means that they are good.
            The final tear of testing is end-to-end testing.
            This is testing which starts your whole service and preferably uses real data.
            Then it completes a journey and reports that it was a success.
            I lied there is another tear but it is the final tear part B.
            Manual testing. I hate manual testing where possible.
            It is laborious and boring. I also have all these other tests which I believe to be correct.
            If I need manual testing I probably did something wrong (or inherited some old ways of working).
            Best thing to remember is Martin Fowler's pyramid. you have mostly unit tests, then some integration, then few end-to-end, and hopefully no manual.
            If you have the correct level of testing and are happy with the results then you can do what you like to the code.
            Because you know you have the correct kind of coverage.
            If you miss out on any of the kinds of testnig.
            Then you end up introducing more bugs.
            We don't like bugs or imperfection and anything to mitigate this is a blessing.
        </h5>
        <h5>
            The last thing that makes tests so freaking unbelievable.
            The thing that if you take nothing else away is the following.
            REFACTOR REFACTOR REFACTOR.
            We do not write anything correct first time.
            Otherwise there would be no need for the backspace button.
            If you want to write good code you have to write bad code.
            You then need to find confidence that you can write better code.
            And when I say better code I mean more bad code.
            I would argue that when you have the FINAL copy of something.
            Just remove the tests and make it so that if anyone wants to change anything they struggle.
        </h5>
        <h5>
            Everyone seems to forget that refactoring means you are happy with your tests.
            That is don't forget to refactor your tests.
            As I said everyone write bad code.
            Which means you all write bad tests.
            So don't forget to refactor them.
            I know what you are thinking, "But I should then write tests for tests!"
            (or "Obviously").
            You just wrote code you know passes your tests.
            So new tests should guarantee that old code still works.
            So in essence your code tests your tests.
        </h5>
        <h5>
            In each paragraph I think I have written something which has annoyed me.
            Something which I have either said makes tests bad at some point.
            Then realized that these are weaknesses but strengths.
            And that these things are what make testing imperative and amazing.
        </h5>
        <h4>Summary</h4>
        <h5>Tests are awesome</h5>
        <h5>Written well they create amazing documentation</h5>
        <h5>Poor tests tell you about poor design</h5>
        <h5>Coupling is shown through poor mocking</h5>
        <h5>Side effects are shown through poor assertions</h5>
        <h5>Correct level of testing reduces bugs and tedious manual testing</h5>
        <h5>All code is bad, but tests let you at least write better bad code</h5>
        <h5>Tests are code so make sure you treat them as such</h5>
    </div>
</body>

</html>
